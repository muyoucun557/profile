# redis的pipeline和事务

redis.cn上对于这二者做了介绍，文章分别是
<http://redis.cn/topics/pipelining.html>
<http://redis.cn/topics/transactions.html>

## tx

事务可以一次执行多个命令，并且带有下面两个重要保证：
1. 是一个单独的隔离操作：事务中的所有命令都会被序列化、按照顺序执行，不会被其他的客户端发来的命令打断。
2. 事务是一个原子操作：要么全部被执行，要么全部都不被执行。

``EXEC``命令负责触发并执行事务中的所有命令：
1. 如果客户端开启了一个事务，但是因为断线没有提交``EXEC``命令，那么事务中的命令都不会被执行
2. 如果客户端成功提交``EXEC``命令，那么所有的事务都会被执行

<strong>redis进程被意外杀死对事务的影响</strong>
redis使用AOF方式持久化的时候，如果redis进程被杀死，那么可能会造成事务中的部分命令写入到磁盘中。
redis在重启之后会发现AOF中存在这样的问题，会丢弃这个不完整的事务。

### MUTIL和EXEC和DISCARD

使用``MUTIL``命令开启一个事务，开启事务之后，客户端可以继续向redis发送多条命令，这些命令不会被立即执行，而是被放到队列中。
当调用``EXEC``命令时，队列中的所有命令才会被执行。
如果调用``DISCARD``，那么会清空该队列。

### 事务中的错误

有两种错误
1. 执行``EXEC``前，入队的命令可能出现错误。命令的语法错误，或者内存不足
2. 调用``EXEC``之后，redis在执行队列中的命令可能失败。比如：处理了错误类型的键，给列表类型的赋值string

对于第一种错误：2.6.5版本之前，需要客户端来检查是否入队成功。入队的时候redis会返回给客户端信息，表明入队是否成功。
如果入队失败，那么需要客户端取消事务。
在2.6.5以及之后，redis服务器会做记录，客户端调用了EXEC，redis服务器会拒绝执行并且放弃事务。

对于第二种错误，出错的命令不会影响队列后面的命令继续执行。

## pipeline

客户端发送请求到redis服务器，等待响应结果，这个过程一般是阻塞的。如果是多个请求，那么阻塞的时间会很长。redis提供了pipe机制，能够让客户端连续发送多个请求，redis服务器在都处理完之后一起响应结果，这样能节约时间（RTT）。

